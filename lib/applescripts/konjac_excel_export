#!/usr/bin/osascript
-- round up ASCII characters used for formatting in Word
global bell
global line_feed
global form_feed
global carriage_return
global format_chars

-- strip line breaks and formatting characters
to strip_line_breaks(this_line)
  try
    -- remove last character until no it's no longer an excluded character
    repeat while last character of this_line is in format_chars
      set this_line to characters 1 thru -2 of this_line as string
    end repeat
    return this_line as text
  on error
    return ""
  end try
end strip_line_breaks

to get_posix_path(mac_path)
  set result to POSIX path of mac_path
end get_posix_path

to extract(filename)
  tell application "Microsoft Excel"
    activate
    open filename
    set active_workbook to active workbook
    set ignored_content to {missing value, "", line_feed}
    
    -- set tags path to full path to active workbook with a .tags extension
    set workbook_path to full name of active_workbook
    set tags_path to workbook_path & ".diff"
    
    -- delete tags file if it already exists
    tell application "Finder"
      if exists file tags_path then
        delete file tags_path
      end if
    end tell
    
    -- open tags file for writing
    set tags_file to open for access file tags_path with write permission
    set eof of tags_file to 0

    write ("--- " & my get_posix_path(workbook_path)) to tags_file
    write line_feed to tags_file
    write ("+++ " & my get_posix_path(workbook_path)) to tags_file
    write line_feed to tags_file

    -- iterate through sheets
    set sheet_index to 1
    set sheet_count to count of sheets in active_workbook

    repeat while sheet_index is less than or equal to sheet_count
      set current_range to used range of sheet sheet_index in active_workbook

      -- iterate through rows
      set row_index to 1
      set row_count to count of rows of current_range
      set column_count to count of columns of current_range

      repeat while row_index is less than or equal to row_count
        -- iterate through columns
        set column_index to 1

        repeat while column_index is less than or equal to column_count
          -- get text content if it's available
          set text_content to my strip_line_breaks(formula of cell column_index of row row_index of current_range) as string

          -- replace "soft returns" (vertical tabs) with real returns
          set old_delimiters to AppleScript's text item delimiters
          set AppleScript's text item delimiters to carriage_return
          set split_content to every text item of text_content
          set AppleScript's text item delimiters to old_delimiters

          if text_content is not in ignored_content then
            write ("@@ " & sheet_index & ":" & row_index & "," & column_index & " @@") to tags_file
            write line_feed to tags_file
            repeat with text_line in split_content
              write ("-" & text_line) to tags_file as «class utf8»
              write line_feed to tags_file
            end repeat
            repeat with text_line in split_content
              write ("+" & text_line) to tags_file as «class utf8»
              write line_feed to tags_file
            end repeat
          end if

          set column_index to (column_index + 1)
        end repeat

        set row_index to (row_index + 1)
      end repeat

      -- increment sheet index
      set sheet_index to (sheet_index + 1)
    end repeat
    
    -- close everything
    close access tags_file
  end tell
end extract

-- initialize global variables, just formatting characters here
to init_globals()
  set bell to ASCII character 7
  set line_feed to ASCII character 10
  set form_feed to ASCII character 12
  set carriage_return to ASCII character 13
  set format_chars to {bell, line_feed, form_feed, carriage_return}
end init_globals

-- main()
on run argv
  init_globals()
  extract(item 1 of argv)
end
