#!/usr/bin/osascript
global numbers_as_text
global line_feed
global vertical_tab
global carriage_return

-- parses the headers/separators inside the tags file
to parse_header(header)
  set at_offset to 4
  
  repeat while character at_offset of header is in my numbers_as_text
    set at_offset to (at_offset + 1)
  end repeat
  
  return at_offset
end parse_header

to ends_with_forbidden_character(txt)
  set last_character to character -1 of txt

  if last_character is in {line_feed, carriage_return, vertical_tab}
    return true
  else
    return false
  end if
end ends_with_forbidden_character

to get_posix_path(mac_path)
  set result to POSIX path of mac_path
end get_posix_path

to import(filename)
  tell application "Microsoft Word"
    activate
    open filename
    set active_document to active document
    set ignored_content to {missing value, "", line_feed}
    
    -- set tags path to full path to active presentation with a .tags extension
    set tags_path to ((path of active_document) & ".diff")
    
    -- read in tags
    set tags_file to open for access file tags_path
    set tags to (read tags_file for (get eof tags_file) ¬
                   as «class utf8» using delimiter line_feed)
    set tag_index to 0
    set tag_length to length of tags
    close access tags_file

    set text_content to ""

    -- iterate through paragraphs
    set paragraph_index to 0
    set prev_paragraph_index to 0
    set is_new_tag to false

    repeat with current_line in tags
      if current_line starts with "@@ " then
        set space_offset to my parse_header(current_line)
        set paragraph_index to text 4 thru space_offset ¬
                                 of current_line as number
        set is_new_tag to true
      else if current_line starts with "+" then
        if paragraph_index is not 0 then
          set prev_paragraph_index to paragraph_index

          -- handle blank lines with soft returns
          if length of current_line is less than 2
            set this_content to ""
          else
            set this_content to text 2 thru (length of current_line) ¬
                                  of current_line
          end if

          -- add to text content, joining with a soft return for multiple lines
          if text_content is "" then
            set text_content to this_content
          else
            set text_content to (text_content & vertical_tab & this_content)
          end if
          set is_new_tag to false
        end if
      end if

      -- increment tag index
      set tag_index to tag_index + 1

      -- write if we've moved to a new tag or reached the end of the file
      if text_content is not "" and (tag_index is tag_length or is_new_tag)
        try
          set current_content to text object of paragraph prev_paragraph_index ¬
                                   of active document
          set my_range to create range active document ¬
                            start (start of content of current_content) ¬
                            end (end of content of current_content)

          select my_range

          -- FIXME: this is super-ugly
          if count of paragraphs of selection is greater than 1
            set my_range to create range active document ¬
                              start (start of content of text object of selection) ¬
                              end ((end of content of text object of selection) - 1)
            select my_range
            repeat while (count of paragraphs of selection is greater than 1)
              -- maybe?
              -- move start of range selection by a line item
            end repeat
          end if

          repeat while my ends_with_forbidden_character(content of selection as text)
            set my_range to create range active document ¬
                              start (start of content of text object of selection) ¬
                              end ((end of content of text object of selection) - 1)
            select my_range
          end repeat

          type text selection text text_content
          set text_content to ""
        end try
      end if
    end repeat
  end tell
end import

-- initialize global variables
to init_globals()
  set numbers_as_text to {"1", "2", "3", "4", "5", "6", "7", "8", "9", "0"}
  set line_feed to ASCII character 10
  set vertical_tab to ASCII character 11
  set carriage_return to ASCII character 13
end init_globals

-- main()
on run argv
  init_globals()
  import(item 1 of argv)
end run
